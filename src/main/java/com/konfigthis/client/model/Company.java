/*
 * Gusto API
 * Welcome to Gusto's Embedded Payroll API documentation!
 *
 * The version of the OpenAPI document: 2024-03-01
 * Contact: developer@gusto.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.CompanyAddress;
import com.konfigthis.client.model.CompanyCompensations;
import com.konfigthis.client.model.CompanyPrimaryPayrollAdmin;
import com.konfigthis.client.model.CompanyPrimarySignatory;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * The representation of a company in Gusto.
 */
@ApiModel(description = "The representation of a company in Gusto.")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class Company {
  public static final String SERIALIZED_NAME_EIN = "ein";
  @SerializedName(SERIALIZED_NAME_EIN)
  private String ein;

  /**
   * The tax payer type of the company.
   */
  @JsonAdapter(EntityTypeEnum.Adapter.class)
 public enum EntityTypeEnum {
    C_CORPORATION("C-Corporation"),
    
    S_CORPORATION("S-Corporation"),
    
    SOLE_PROPRIETOR("Sole proprietor"),
    
    LLC("LLC"),
    
    LLP("LLP"),
    
    LIMITED_PARTNERSHIP("Limited partnership"),
    
    CO_OWNERSHIP("Co-ownership"),
    
    ASSOCIATION("Association"),
    
    TRUSTEESHIP("Trusteeship"),
    
    GENERAL_PARTNERSHIP("General partnership"),
    
    JOINT_VENTURE("Joint venture"),
    
    NON_PROFIT("Non-Profit");

    private String value;

    EntityTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EntityTypeEnum fromValue(String value) {
      for (EntityTypeEnum b : EntityTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EntityTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EntityTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EntityTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EntityTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ENTITY_TYPE = "entity_type";
  @SerializedName(SERIALIZED_NAME_ENTITY_TYPE)
  private EntityTypeEnum entityType;

  /**
   * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
   */
  @JsonAdapter(TierEnum.Adapter.class)
 public enum TierEnum {
    SIMPLE("simple"),
    
    PLUS("plus"),
    
    PREMIUM("premium"),
    
    CORE("core"),
    
    COMPLETE("complete"),
    
    CONCIERGE("concierge"),
    
    CONTRACTOR_ONLY("contractor_only"),
    
    BASIC("basic");

    private String value;

    TierEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TierEnum fromValue(String value) {
      for (TierEnum b : TierEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TierEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TierEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TierEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TierEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TIER = "tier";
  @SerializedName(SERIALIZED_NAME_TIER)
  private TierEnum tier;

  public static final String SERIALIZED_NAME_IS_SUSPENDED = "is_suspended";
  @SerializedName(SERIALIZED_NAME_IS_SUSPENDED)
  private Boolean isSuspended;

  /**
   * The status of the company in Gusto. \&quot;Approved\&quot; companies may run payroll with Gusto. \&quot;Not Approved\&quot; companies may not yet run payroll with Gusto. In order to run payroll, the company may need to complete onboarding or contact support. \&quot;Suspended\&quot; companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
   */
  @JsonAdapter(CompanyStatusEnum.Adapter.class)
 public enum CompanyStatusEnum {
    APPROVED("Approved"),
    
    NOT_APPROVED("Not Approved"),
    
    SUSPENDED("Suspended");

    private String value;

    CompanyStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CompanyStatusEnum fromValue(String value) {
      for (CompanyStatusEnum b : CompanyStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CompanyStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CompanyStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CompanyStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CompanyStatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_COMPANY_STATUS = "company_status";
  @SerializedName(SERIALIZED_NAME_COMPANY_STATUS)
  private CompanyStatusEnum companyStatus;

  public static final String SERIALIZED_NAME_UUID = "uuid";
  @SerializedName(SERIALIZED_NAME_UUID)
  private String uuid;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_TRADE_NAME = "trade_name";
  @SerializedName(SERIALIZED_NAME_TRADE_NAME)
  private String tradeName;

  public static final String SERIALIZED_NAME_IS_PARTNER_MANAGED = "is_partner_managed";
  @SerializedName(SERIALIZED_NAME_IS_PARTNER_MANAGED)
  private Boolean isPartnerManaged;

  /**
   * The pay schedule assignment type.
   */
  @JsonAdapter(PayScheduleTypeEnum.Adapter.class)
 public enum PayScheduleTypeEnum {
    SINGLE("single"),
    
    HOURLY_SALARIED("hourly_salaried"),
    
    BY_EMPLOYEE("by_employee"),
    
    BY_DEPARTMENT("by_department");

    private String value;

    PayScheduleTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PayScheduleTypeEnum fromValue(String value) {
      for (PayScheduleTypeEnum b : PayScheduleTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PayScheduleTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PayScheduleTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PayScheduleTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PayScheduleTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PAY_SCHEDULE_TYPE = "pay_schedule_type";
  @SerializedName(SERIALIZED_NAME_PAY_SCHEDULE_TYPE)
  private PayScheduleTypeEnum payScheduleType;

  public static final String SERIALIZED_NAME_JOIN_DATE = "join_date";
  @SerializedName(SERIALIZED_NAME_JOIN_DATE)
  private String joinDate;

  /**
   * Company&#39;s default funding type
   */
  @JsonAdapter(FundingTypeEnum.Adapter.class)
 public enum FundingTypeEnum {
    ACH("ach"),
    
    REVERSE_WIRE("reverse_wire"),
    
    WIRE_IN("wire_in"),
    
    BREX("brex");

    private String value;

    FundingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FundingTypeEnum fromValue(String value) {
      for (FundingTypeEnum b : FundingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FundingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FundingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FundingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FundingTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_FUNDING_TYPE = "funding_type";
  @SerializedName(SERIALIZED_NAME_FUNDING_TYPE)
  private FundingTypeEnum fundingType;

  public static final String SERIALIZED_NAME_LOCATIONS = "locations";
  @SerializedName(SERIALIZED_NAME_LOCATIONS)
  private List<CompanyAddress> locations = null;

  public static final String SERIALIZED_NAME_COMPENSATIONS = "compensations";
  @SerializedName(SERIALIZED_NAME_COMPENSATIONS)
  private CompanyCompensations compensations;

  public static final String SERIALIZED_NAME_PRIMARY_SIGNATORY = "primary_signatory";
  @SerializedName(SERIALIZED_NAME_PRIMARY_SIGNATORY)
  private CompanyPrimarySignatory primarySignatory;

  public static final String SERIALIZED_NAME_PRIMARY_PAYROLL_ADMIN = "primary_payroll_admin";
  @SerializedName(SERIALIZED_NAME_PRIMARY_PAYROLL_ADMIN)
  private CompanyPrimaryPayrollAdmin primaryPayrollAdmin;

  public Company() {
  }

  
  public Company(
     String ein, 
     EntityTypeEnum entityType, 
     TierEnum tier, 
     CompanyStatusEnum companyStatus, 
     String uuid, 
     String name, 
     String tradeName, 
     Boolean isPartnerManaged, 
     PayScheduleTypeEnum payScheduleType, 
     String joinDate, 
     List<CompanyAddress> locations
  ) {
    this();
    this.ein = ein;
    this.entityType = entityType;
    this.tier = tier;
    this.companyStatus = companyStatus;
    this.uuid = uuid;
    this.name = name;
    this.tradeName = tradeName;
    this.isPartnerManaged = isPartnerManaged;
    this.payScheduleType = payScheduleType;
    this.joinDate = joinDate;
    this.locations = locations;
  }

   /**
   * The Federal Employer Identification Number of the company.
   * @return ein
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "00-0000001", value = "The Federal Employer Identification Number of the company.")

  public String getEin() {
    return ein;
  }




   /**
   * The tax payer type of the company.
   * @return entityType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "C_CORPORATION", value = "The tax payer type of the company.")

  public EntityTypeEnum getEntityType() {
    return entityType;
  }




   /**
   * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
   * @return tier
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "COMPLETE", value = "The Gusto product tier of the company (not applicable to Embedded partner managed companies).")

  public TierEnum getTier() {
    return tier;
  }




  public Company isSuspended(Boolean isSuspended) {
    
    
    
    
    this.isSuspended = isSuspended;
    return this;
  }

   /**
   * Whether or not the company is suspended in Gusto. Suspended companies may not run payroll.
   * @return isSuspended
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Whether or not the company is suspended in Gusto. Suspended companies may not run payroll.")

  public Boolean getIsSuspended() {
    return isSuspended;
  }


  public void setIsSuspended(Boolean isSuspended) {
    
    
    
    this.isSuspended = isSuspended;
  }


   /**
   * The status of the company in Gusto. \&quot;Approved\&quot; companies may run payroll with Gusto. \&quot;Not Approved\&quot; companies may not yet run payroll with Gusto. In order to run payroll, the company may need to complete onboarding or contact support. \&quot;Suspended\&quot; companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
   * @return companyStatus
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "APPROVED", value = "The status of the company in Gusto. \"Approved\" companies may run payroll with Gusto. \"Not Approved\" companies may not yet run payroll with Gusto. In order to run payroll, the company may need to complete onboarding or contact support. \"Suspended\" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.")

  public CompanyStatusEnum getCompanyStatus() {
    return companyStatus;
  }




   /**
   * A unique identifier of the company in Gusto.
   * @return uuid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A unique identifier of the company in Gusto.")

  public String getUuid() {
    return uuid;
  }




   /**
   * The name of the company.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Shoppe Studios LLC", value = "The name of the company.")

  public String getName() {
    return name;
  }




   /**
   * The trade name of the company.
   * @return tradeName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Record Shoppe", value = "The trade name of the company.")

  public String getTradeName() {
    return tradeName;
  }




   /**
   * Whether the company is fully managed by a partner via the API
   * @return isPartnerManaged
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Whether the company is fully managed by a partner via the API")

  public Boolean getIsPartnerManaged() {
    return isPartnerManaged;
  }




   /**
   * The pay schedule assignment type.
   * @return payScheduleType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "BY_DEPARTMENT", value = "The pay schedule assignment type.")

  public PayScheduleTypeEnum getPayScheduleType() {
    return payScheduleType;
  }




   /**
   * Company&#39;s first invoiceable event date
   * @return joinDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Company's first invoiceable event date")

  public String getJoinDate() {
    return joinDate;
  }




  public Company fundingType(FundingTypeEnum fundingType) {
    
    
    
    
    this.fundingType = fundingType;
    return this;
  }

   /**
   * Company&#39;s default funding type
   * @return fundingType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Company's default funding type")

  public FundingTypeEnum getFundingType() {
    return fundingType;
  }


  public void setFundingType(FundingTypeEnum fundingType) {
    
    
    
    this.fundingType = fundingType;
  }


   /**
   * The locations of the company.
   * @return locations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The locations of the company.")

  public List<CompanyAddress> getLocations() {
    return locations;
  }




  public Company compensations(CompanyCompensations compensations) {
    
    
    
    
    this.compensations = compensations;
    return this;
  }

   /**
   * Get compensations
   * @return compensations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CompanyCompensations getCompensations() {
    return compensations;
  }


  public void setCompensations(CompanyCompensations compensations) {
    
    
    
    this.compensations = compensations;
  }


  public Company primarySignatory(CompanyPrimarySignatory primarySignatory) {
    
    
    
    
    this.primarySignatory = primarySignatory;
    return this;
  }

   /**
   * Get primarySignatory
   * @return primarySignatory
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CompanyPrimarySignatory getPrimarySignatory() {
    return primarySignatory;
  }


  public void setPrimarySignatory(CompanyPrimarySignatory primarySignatory) {
    
    
    
    this.primarySignatory = primarySignatory;
  }


  public Company primaryPayrollAdmin(CompanyPrimaryPayrollAdmin primaryPayrollAdmin) {
    
    
    
    
    this.primaryPayrollAdmin = primaryPayrollAdmin;
    return this;
  }

   /**
   * Get primaryPayrollAdmin
   * @return primaryPayrollAdmin
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CompanyPrimaryPayrollAdmin getPrimaryPayrollAdmin() {
    return primaryPayrollAdmin;
  }


  public void setPrimaryPayrollAdmin(CompanyPrimaryPayrollAdmin primaryPayrollAdmin) {
    
    
    
    this.primaryPayrollAdmin = primaryPayrollAdmin;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the Company instance itself
   */
  public Company putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Company company = (Company) o;
    return Objects.equals(this.ein, company.ein) &&
        Objects.equals(this.entityType, company.entityType) &&
        Objects.equals(this.tier, company.tier) &&
        Objects.equals(this.isSuspended, company.isSuspended) &&
        Objects.equals(this.companyStatus, company.companyStatus) &&
        Objects.equals(this.uuid, company.uuid) &&
        Objects.equals(this.name, company.name) &&
        Objects.equals(this.tradeName, company.tradeName) &&
        Objects.equals(this.isPartnerManaged, company.isPartnerManaged) &&
        Objects.equals(this.payScheduleType, company.payScheduleType) &&
        Objects.equals(this.joinDate, company.joinDate) &&
        Objects.equals(this.fundingType, company.fundingType) &&
        Objects.equals(this.locations, company.locations) &&
        Objects.equals(this.compensations, company.compensations) &&
        Objects.equals(this.primarySignatory, company.primarySignatory) &&
        Objects.equals(this.primaryPayrollAdmin, company.primaryPayrollAdmin)&&
        Objects.equals(this.additionalProperties, company.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(ein, entityType, tier, isSuspended, companyStatus, uuid, name, tradeName, isPartnerManaged, payScheduleType, joinDate, fundingType, locations, compensations, primarySignatory, primaryPayrollAdmin, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Company {\n");
    sb.append("    ein: ").append(toIndentedString(ein)).append("\n");
    sb.append("    entityType: ").append(toIndentedString(entityType)).append("\n");
    sb.append("    tier: ").append(toIndentedString(tier)).append("\n");
    sb.append("    isSuspended: ").append(toIndentedString(isSuspended)).append("\n");
    sb.append("    companyStatus: ").append(toIndentedString(companyStatus)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    tradeName: ").append(toIndentedString(tradeName)).append("\n");
    sb.append("    isPartnerManaged: ").append(toIndentedString(isPartnerManaged)).append("\n");
    sb.append("    payScheduleType: ").append(toIndentedString(payScheduleType)).append("\n");
    sb.append("    joinDate: ").append(toIndentedString(joinDate)).append("\n");
    sb.append("    fundingType: ").append(toIndentedString(fundingType)).append("\n");
    sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
    sb.append("    compensations: ").append(toIndentedString(compensations)).append("\n");
    sb.append("    primarySignatory: ").append(toIndentedString(primarySignatory)).append("\n");
    sb.append("    primaryPayrollAdmin: ").append(toIndentedString(primaryPayrollAdmin)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ein");
    openapiFields.add("entity_type");
    openapiFields.add("tier");
    openapiFields.add("is_suspended");
    openapiFields.add("company_status");
    openapiFields.add("uuid");
    openapiFields.add("name");
    openapiFields.add("trade_name");
    openapiFields.add("is_partner_managed");
    openapiFields.add("pay_schedule_type");
    openapiFields.add("join_date");
    openapiFields.add("funding_type");
    openapiFields.add("locations");
    openapiFields.add("compensations");
    openapiFields.add("primary_signatory");
    openapiFields.add("primary_payroll_admin");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Company
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Company.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Company is not found in the empty JSON string", Company.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("ein") != null && !jsonObj.get("ein").isJsonNull()) && !jsonObj.get("ein").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ein` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ein").toString()));
      }
      if ((jsonObj.get("entity_type") != null && !jsonObj.get("entity_type").isJsonNull()) && !jsonObj.get("entity_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entity_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entity_type").toString()));
      }
      if (!jsonObj.get("tier").isJsonNull() && (jsonObj.get("tier") != null && !jsonObj.get("tier").isJsonNull()) && !jsonObj.get("tier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tier").toString()));
      }
      if ((jsonObj.get("company_status") != null && !jsonObj.get("company_status").isJsonNull()) && !jsonObj.get("company_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `company_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("company_status").toString()));
      }
      if ((jsonObj.get("uuid") != null && !jsonObj.get("uuid").isJsonNull()) && !jsonObj.get("uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uuid").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("trade_name") != null && !jsonObj.get("trade_name").isJsonNull()) && !jsonObj.get("trade_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trade_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trade_name").toString()));
      }
      if ((jsonObj.get("pay_schedule_type") != null && !jsonObj.get("pay_schedule_type").isJsonNull()) && !jsonObj.get("pay_schedule_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pay_schedule_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pay_schedule_type").toString()));
      }
      if ((jsonObj.get("join_date") != null && !jsonObj.get("join_date").isJsonNull()) && !jsonObj.get("join_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `join_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("join_date").toString()));
      }
      if ((jsonObj.get("funding_type") != null && !jsonObj.get("funding_type").isJsonNull()) && !jsonObj.get("funding_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `funding_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("funding_type").toString()));
      }
      if (jsonObj.get("locations") != null && !jsonObj.get("locations").isJsonNull()) {
        JsonArray jsonArraylocations = jsonObj.getAsJsonArray("locations");
        if (jsonArraylocations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("locations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `locations` to be an array in the JSON string but got `%s`", jsonObj.get("locations").toString()));
          }

          // validate the optional field `locations` (array)
          for (int i = 0; i < jsonArraylocations.size(); i++) {
            CompanyAddress.validateJsonObject(jsonArraylocations.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `compensations`
      if (jsonObj.get("compensations") != null && !jsonObj.get("compensations").isJsonNull()) {
        CompanyCompensations.validateJsonObject(jsonObj.getAsJsonObject("compensations"));
      }
      // validate the optional field `primary_signatory`
      if (jsonObj.get("primary_signatory") != null && !jsonObj.get("primary_signatory").isJsonNull()) {
        CompanyPrimarySignatory.validateJsonObject(jsonObj.getAsJsonObject("primary_signatory"));
      }
      // validate the optional field `primary_payroll_admin`
      if (jsonObj.get("primary_payroll_admin") != null && !jsonObj.get("primary_payroll_admin").isJsonNull()) {
        CompanyPrimaryPayrollAdmin.validateJsonObject(jsonObj.getAsJsonObject("primary_payroll_admin"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Company.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Company' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Company> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Company.class));

       return (TypeAdapter<T>) new TypeAdapter<Company>() {
           @Override
           public void write(JsonWriter out, Company value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public Company read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             Company instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Company given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Company
  * @throws IOException if the JSON string is invalid with respect to Company
  */
  public static Company fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Company.class);
  }

 /**
  * Convert an instance of Company to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


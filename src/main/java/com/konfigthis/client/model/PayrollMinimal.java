/*
 * Gusto API
 * Welcome to Gusto's Embedded Payroll API documentation!
 *
 * The version of the OpenAPI document: 2024-03-01
 * Contact: developer@gusto.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.OffCycleReasonType;
import com.konfigthis.client.model.PayrollPayPeriodType;
import com.konfigthis.client.model.PayrollPaymentSpeedChangedType;
import com.konfigthis.client.model.PayrollPayrollStatusMetaType;
import com.konfigthis.client.model.PayrollTotalsType;
import com.konfigthis.client.model.PayrollWithholdingPayPeriodType;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * 
 */
@ApiModel(description = "")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class PayrollMinimal {
  public static final String SERIALIZED_NAME_PAYROLL_DEADLINE = "payroll_deadline";
  @SerializedName(SERIALIZED_NAME_PAYROLL_DEADLINE)
  private OffsetDateTime payrollDeadline;

  public static final String SERIALIZED_NAME_CHECK_DATE = "check_date";
  @SerializedName(SERIALIZED_NAME_CHECK_DATE)
  private String checkDate;

  public static final String SERIALIZED_NAME_PROCESSED = "processed";
  @SerializedName(SERIALIZED_NAME_PROCESSED)
  private Boolean processed;

  public static final String SERIALIZED_NAME_PROCESSED_DATE = "processed_date";
  @SerializedName(SERIALIZED_NAME_PROCESSED_DATE)
  private String processedDate;

  public static final String SERIALIZED_NAME_CALCULATED_AT = "calculated_at";
  @SerializedName(SERIALIZED_NAME_CALCULATED_AT)
  private String calculatedAt;

  public static final String SERIALIZED_NAME_PAYROLL_UUID = "payroll_uuid";
  @SerializedName(SERIALIZED_NAME_PAYROLL_UUID)
  private String payrollUuid;

  public static final String SERIALIZED_NAME_COMPANY_UUID = "company_uuid";
  @SerializedName(SERIALIZED_NAME_COMPANY_UUID)
  private String companyUuid;

  public static final String SERIALIZED_NAME_OFF_CYCLE = "off_cycle";
  @SerializedName(SERIALIZED_NAME_OFF_CYCLE)
  private Boolean offCycle;

  public static final String SERIALIZED_NAME_OFF_CYCLE_REASON = "off_cycle_reason";
  @SerializedName(SERIALIZED_NAME_OFF_CYCLE_REASON)
  private OffCycleReasonType offCycleReason;

  public static final String SERIALIZED_NAME_EXTERNAL = "external";
  @SerializedName(SERIALIZED_NAME_EXTERNAL)
  private Boolean external;

  public static final String SERIALIZED_NAME_FINAL_TERMINATION_PAYROLL = "final_termination_payroll";
  @SerializedName(SERIALIZED_NAME_FINAL_TERMINATION_PAYROLL)
  private Boolean finalTerminationPayroll;

  public static final String SERIALIZED_NAME_WITHHOLDING_PAY_PERIOD = "withholding_pay_period";
  @SerializedName(SERIALIZED_NAME_WITHHOLDING_PAY_PERIOD)
  private PayrollWithholdingPayPeriodType withholdingPayPeriod;

  public static final String SERIALIZED_NAME_SKIP_REGULAR_DEDUCTIONS = "skip_regular_deductions";
  @SerializedName(SERIALIZED_NAME_SKIP_REGULAR_DEDUCTIONS)
  private Boolean skipRegularDeductions;

  public static final String SERIALIZED_NAME_FIXED_WITHHOLDING_RATE = "fixed_withholding_rate";
  @SerializedName(SERIALIZED_NAME_FIXED_WITHHOLDING_RATE)
  private Boolean fixedWithholdingRate;

  public static final String SERIALIZED_NAME_PAY_PERIOD = "pay_period";
  @SerializedName(SERIALIZED_NAME_PAY_PERIOD)
  private PayrollPayPeriodType payPeriod;

  public static final String SERIALIZED_NAME_PAYROLL_STATUS_META = "payroll_status_meta";
  @SerializedName(SERIALIZED_NAME_PAYROLL_STATUS_META)
  private PayrollPayrollStatusMetaType payrollStatusMeta;

  public static final String SERIALIZED_NAME_TOTALS = "totals";
  @SerializedName(SERIALIZED_NAME_TOTALS)
  private PayrollTotalsType totals;

  public static final String SERIALIZED_NAME_PAYMENT_SPEED_CHANGED = "payment_speed_changed";
  @SerializedName(SERIALIZED_NAME_PAYMENT_SPEED_CHANGED)
  private PayrollPaymentSpeedChangedType paymentSpeedChanged;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public PayrollMinimal() {
  }

  
  public PayrollMinimal(
     OffsetDateTime payrollDeadline, 
     String checkDate, 
     Boolean processed, 
     String processedDate, 
     String calculatedAt, 
     String payrollUuid, 
     String companyUuid, 
     Boolean offCycle, 
     Boolean external, 
     Boolean finalTerminationPayroll, 
     Boolean skipRegularDeductions, 
     Boolean fixedWithholdingRate, 
     OffsetDateTime createdAt
  ) {
    this();
    this.payrollDeadline = payrollDeadline;
    this.checkDate = checkDate;
    this.processed = processed;
    this.processedDate = processedDate;
    this.calculatedAt = calculatedAt;
    this.payrollUuid = payrollUuid;
    this.companyUuid = companyUuid;
    this.offCycle = offCycle;
    this.external = external;
    this.finalTerminationPayroll = finalTerminationPayroll;
    this.skipRegularDeductions = skipRegularDeductions;
    this.fixedWithholdingRate = fixedWithholdingRate;
    this.createdAt = createdAt;
  }

   /**
   * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.
   * @return payrollDeadline
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.")

  public OffsetDateTime getPayrollDeadline() {
    return payrollDeadline;
  }




   /**
   * The date on which employees will be paid for the payroll.
   * @return checkDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date on which employees will be paid for the payroll.")

  public String getCheckDate() {
    return checkDate;
  }




   /**
   * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
   * @return processed
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.")

  public Boolean getProcessed() {
    return processed;
  }




   /**
   * The date at which the payroll was processed. Null if the payroll isn&#39;t processed yet.
   * @return processedDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date at which the payroll was processed. Null if the payroll isn't processed yet.")

  public String getProcessedDate() {
    return processedDate;
  }




   /**
   * A timestamp of the last valid payroll calculation. Null is there isn&#39;t a valid calculation.
   * @return calculatedAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A timestamp of the last valid payroll calculation. Null is there isn't a valid calculation.")

  public String getCalculatedAt() {
    return calculatedAt;
  }




   /**
   * The UUID of the payroll.
   * @return payrollUuid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The UUID of the payroll.")

  public String getPayrollUuid() {
    return payrollUuid;
  }




   /**
   * The UUID of the company for the payroll.
   * @return companyUuid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The UUID of the company for the payroll.")

  public String getCompanyUuid() {
    return companyUuid;
  }




   /**
   * Indicates whether the payroll is an off-cycle payroll
   * @return offCycle
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the payroll is an off-cycle payroll")

  public Boolean getOffCycle() {
    return offCycle;
  }




  public PayrollMinimal offCycleReason(OffCycleReasonType offCycleReason) {
    
    
    
    
    this.offCycleReason = offCycleReason;
    return this;
  }

   /**
   * Get offCycleReason
   * @return offCycleReason
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffCycleReasonType getOffCycleReason() {
    return offCycleReason;
  }


  public void setOffCycleReason(OffCycleReasonType offCycleReason) {
    
    
    
    this.offCycleReason = offCycleReason;
  }


   /**
   * Indicates whether the payroll is an external payroll
   * @return external
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the payroll is an external payroll")

  public Boolean getExternal() {
    return external;
  }




   /**
   * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
   * @return finalTerminationPayroll
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.")

  public Boolean getFinalTerminationPayroll() {
    return finalTerminationPayroll;
  }




  public PayrollMinimal withholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
    
    
    
    
    this.withholdingPayPeriod = withholdingPayPeriod;
    return this;
  }

   /**
   * Get withholdingPayPeriod
   * @return withholdingPayPeriod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayrollWithholdingPayPeriodType getWithholdingPayPeriod() {
    return withholdingPayPeriod;
  }


  public void setWithholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
    
    
    
    this.withholdingPayPeriod = withholdingPayPeriod;
  }


   /**
   * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
   * @return skipRegularDeductions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.")

  public Boolean getSkipRegularDeductions() {
    return skipRegularDeductions;
  }




   /**
   * Enable taxes to be withheld at the IRS&#39;s required rate of 22% for federal income taxes. State income taxes will be taxed at the state&#39;s supplemental tax rate. Otherwise, we&#39;ll sum the entirety of the employee&#39;s wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
   * @return fixedWithholdingRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.")

  public Boolean getFixedWithholdingRate() {
    return fixedWithholdingRate;
  }




  public PayrollMinimal payPeriod(PayrollPayPeriodType payPeriod) {
    
    
    
    
    this.payPeriod = payPeriod;
    return this;
  }

   /**
   * Get payPeriod
   * @return payPeriod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayrollPayPeriodType getPayPeriod() {
    return payPeriod;
  }


  public void setPayPeriod(PayrollPayPeriodType payPeriod) {
    
    
    
    this.payPeriod = payPeriod;
  }


  public PayrollMinimal payrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
    
    
    
    
    this.payrollStatusMeta = payrollStatusMeta;
    return this;
  }

   /**
   * Get payrollStatusMeta
   * @return payrollStatusMeta
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayrollPayrollStatusMetaType getPayrollStatusMeta() {
    return payrollStatusMeta;
  }


  public void setPayrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
    
    
    
    this.payrollStatusMeta = payrollStatusMeta;
  }


  public PayrollMinimal totals(PayrollTotalsType totals) {
    
    
    
    
    this.totals = totals;
    return this;
  }

   /**
   * Get totals
   * @return totals
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayrollTotalsType getTotals() {
    return totals;
  }


  public void setTotals(PayrollTotalsType totals) {
    
    
    
    this.totals = totals;
  }


  public PayrollMinimal paymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
    
    
    
    
    this.paymentSpeedChanged = paymentSpeedChanged;
    return this;
  }

   /**
   * Get paymentSpeedChanged
   * @return paymentSpeedChanged
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayrollPaymentSpeedChangedType getPaymentSpeedChanged() {
    return paymentSpeedChanged;
  }


  public void setPaymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
    
    
    
    this.paymentSpeedChanged = paymentSpeedChanged;
  }


   /**
   * Datetime for when the resource was created.
   * @return createdAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Datetime for when the resource was created.")

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the PayrollMinimal instance itself
   */
  public PayrollMinimal putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PayrollMinimal payrollMinimal = (PayrollMinimal) o;
    return Objects.equals(this.payrollDeadline, payrollMinimal.payrollDeadline) &&
        Objects.equals(this.checkDate, payrollMinimal.checkDate) &&
        Objects.equals(this.processed, payrollMinimal.processed) &&
        Objects.equals(this.processedDate, payrollMinimal.processedDate) &&
        Objects.equals(this.calculatedAt, payrollMinimal.calculatedAt) &&
        Objects.equals(this.payrollUuid, payrollMinimal.payrollUuid) &&
        Objects.equals(this.companyUuid, payrollMinimal.companyUuid) &&
        Objects.equals(this.offCycle, payrollMinimal.offCycle) &&
        Objects.equals(this.offCycleReason, payrollMinimal.offCycleReason) &&
        Objects.equals(this.external, payrollMinimal.external) &&
        Objects.equals(this.finalTerminationPayroll, payrollMinimal.finalTerminationPayroll) &&
        Objects.equals(this.withholdingPayPeriod, payrollMinimal.withholdingPayPeriod) &&
        Objects.equals(this.skipRegularDeductions, payrollMinimal.skipRegularDeductions) &&
        Objects.equals(this.fixedWithholdingRate, payrollMinimal.fixedWithholdingRate) &&
        Objects.equals(this.payPeriod, payrollMinimal.payPeriod) &&
        Objects.equals(this.payrollStatusMeta, payrollMinimal.payrollStatusMeta) &&
        Objects.equals(this.totals, payrollMinimal.totals) &&
        Objects.equals(this.paymentSpeedChanged, payrollMinimal.paymentSpeedChanged) &&
        Objects.equals(this.createdAt, payrollMinimal.createdAt)&&
        Objects.equals(this.additionalProperties, payrollMinimal.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(payrollDeadline, checkDate, processed, processedDate, calculatedAt, payrollUuid, companyUuid, offCycle, offCycleReason, external, finalTerminationPayroll, withholdingPayPeriod, skipRegularDeductions, fixedWithholdingRate, payPeriod, payrollStatusMeta, totals, paymentSpeedChanged, createdAt, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PayrollMinimal {\n");
    sb.append("    payrollDeadline: ").append(toIndentedString(payrollDeadline)).append("\n");
    sb.append("    checkDate: ").append(toIndentedString(checkDate)).append("\n");
    sb.append("    processed: ").append(toIndentedString(processed)).append("\n");
    sb.append("    processedDate: ").append(toIndentedString(processedDate)).append("\n");
    sb.append("    calculatedAt: ").append(toIndentedString(calculatedAt)).append("\n");
    sb.append("    payrollUuid: ").append(toIndentedString(payrollUuid)).append("\n");
    sb.append("    companyUuid: ").append(toIndentedString(companyUuid)).append("\n");
    sb.append("    offCycle: ").append(toIndentedString(offCycle)).append("\n");
    sb.append("    offCycleReason: ").append(toIndentedString(offCycleReason)).append("\n");
    sb.append("    external: ").append(toIndentedString(external)).append("\n");
    sb.append("    finalTerminationPayroll: ").append(toIndentedString(finalTerminationPayroll)).append("\n");
    sb.append("    withholdingPayPeriod: ").append(toIndentedString(withholdingPayPeriod)).append("\n");
    sb.append("    skipRegularDeductions: ").append(toIndentedString(skipRegularDeductions)).append("\n");
    sb.append("    fixedWithholdingRate: ").append(toIndentedString(fixedWithholdingRate)).append("\n");
    sb.append("    payPeriod: ").append(toIndentedString(payPeriod)).append("\n");
    sb.append("    payrollStatusMeta: ").append(toIndentedString(payrollStatusMeta)).append("\n");
    sb.append("    totals: ").append(toIndentedString(totals)).append("\n");
    sb.append("    paymentSpeedChanged: ").append(toIndentedString(paymentSpeedChanged)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("payroll_deadline");
    openapiFields.add("check_date");
    openapiFields.add("processed");
    openapiFields.add("processed_date");
    openapiFields.add("calculated_at");
    openapiFields.add("payroll_uuid");
    openapiFields.add("company_uuid");
    openapiFields.add("off_cycle");
    openapiFields.add("off_cycle_reason");
    openapiFields.add("external");
    openapiFields.add("final_termination_payroll");
    openapiFields.add("withholding_pay_period");
    openapiFields.add("skip_regular_deductions");
    openapiFields.add("fixed_withholding_rate");
    openapiFields.add("pay_period");
    openapiFields.add("payroll_status_meta");
    openapiFields.add("totals");
    openapiFields.add("payment_speed_changed");
    openapiFields.add("created_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to PayrollMinimal
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!PayrollMinimal.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PayrollMinimal is not found in the empty JSON string", PayrollMinimal.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("check_date") != null && !jsonObj.get("check_date").isJsonNull()) && !jsonObj.get("check_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `check_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("check_date").toString()));
      }
      if ((jsonObj.get("processed_date") != null && !jsonObj.get("processed_date").isJsonNull()) && !jsonObj.get("processed_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `processed_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("processed_date").toString()));
      }
      if ((jsonObj.get("calculated_at") != null && !jsonObj.get("calculated_at").isJsonNull()) && !jsonObj.get("calculated_at").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `calculated_at` to be a primitive type in the JSON string but got `%s`", jsonObj.get("calculated_at").toString()));
      }
      if ((jsonObj.get("payroll_uuid") != null && !jsonObj.get("payroll_uuid").isJsonNull()) && !jsonObj.get("payroll_uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payroll_uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payroll_uuid").toString()));
      }
      if ((jsonObj.get("company_uuid") != null && !jsonObj.get("company_uuid").isJsonNull()) && !jsonObj.get("company_uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `company_uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("company_uuid").toString()));
      }
      // validate the optional field `pay_period`
      if (jsonObj.get("pay_period") != null && !jsonObj.get("pay_period").isJsonNull()) {
        PayrollPayPeriodType.validateJsonObject(jsonObj.getAsJsonObject("pay_period"));
      }
      // validate the optional field `payroll_status_meta`
      if (jsonObj.get("payroll_status_meta") != null && !jsonObj.get("payroll_status_meta").isJsonNull()) {
        PayrollPayrollStatusMetaType.validateJsonObject(jsonObj.getAsJsonObject("payroll_status_meta"));
      }
      // validate the optional field `totals`
      if (jsonObj.get("totals") != null && !jsonObj.get("totals").isJsonNull()) {
        PayrollTotalsType.validateJsonObject(jsonObj.getAsJsonObject("totals"));
      }
      // validate the optional field `payment_speed_changed`
      if (jsonObj.get("payment_speed_changed") != null && !jsonObj.get("payment_speed_changed").isJsonNull()) {
        PayrollPaymentSpeedChangedType.validateJsonObject(jsonObj.getAsJsonObject("payment_speed_changed"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PayrollMinimal.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PayrollMinimal' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PayrollMinimal> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PayrollMinimal.class));

       return (TypeAdapter<T>) new TypeAdapter<PayrollMinimal>() {
           @Override
           public void write(JsonWriter out, PayrollMinimal value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public PayrollMinimal read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             PayrollMinimal instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of PayrollMinimal given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of PayrollMinimal
  * @throws IOException if the JSON string is invalid with respect to PayrollMinimal
  */
  public static PayrollMinimal fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PayrollMinimal.class);
  }

 /**
  * Convert an instance of PayrollMinimal to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

